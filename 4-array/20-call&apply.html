<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>call & apply</title>
    <script>
        "use strict";

        /*
         * # call 和 apply
         *
         * 根据函数调用方式的不同，`this` 的值也不同：
         *
         * 1. 以函数形式调用，`this` 的值是 `window`
         * 2. 以方法形式调用，`this` 是调用方法的对象
         * 3. 构造函数中，`this` 是新建的对象
         * 4. 箭头函数没有自己的 `this`，由外层作用域决定
         * 5. 通过 `call()` 和 `apply()` 调用的函数，它们的第一个参数就是函数的 `this`
         * 6. 通过 `bind()` 返回的函数，`this` 由 `bind` 的第一个参数决定（无法修改）
         *
         * 调用函数除了通过 `函数()` 这种形式之外，还可以通过其它的方式来调用函数：
         *
         * - 通过调用函数的 `call()` 和 `apply()` 两个方法来调用函数
         * - `call()` 和 `apply()` 除了可以调用函数，还可以用来指定函数中的 `this`
         */
        function fn1() {
            console.log("我是 fn 函数");
            console.log(this);
        }

        const o = {name: "icekylin", fn1};

        fn1.call();
        fn1.call(o);

        console.log("\n");

        fn1.apply();
        fn1.apply(o);
        fn1.apply(console);

        console.log("\n");

        /*
         * - 通过 `call()` 调用函数，调用的实参直接在第一个参数后一个一个的列出来
         * - 通过 `apply()` 调用函数，调用的实参需要通过一个数组传递
         */
        function fn2(a, b) {
            console.log(`a = ${a},b = ${b}`);
            console.log(this);
        }

        fn2.call(o, 1, 2);
        fn2.apply(o, [1, 2]);
    </script>
</head>
<body></body>
</html>
